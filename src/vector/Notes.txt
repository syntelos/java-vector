
Documentation

  Employing RFC 2119 style.

  http://tools.ietf.org/html/rfc2119


Requirements

  1

    Scalable vector graphics paradigm resizes the window frame and content

    Scripting of static and dynamic window content via JPL subclasses

  2

    Media (e.g. JSON) define and update window content as a tree of
    named components

    Update deltas modify subtree components by specifying ancestors by
    name, not content

    Component names are array indeces from zero inclusive.

    Save JSON, Control-S, save to file
    Open JSON, Control-O, load from file

  3

    Plot static and dynamic data via original import/export data sets

    Data import, Control-I, load from file
    Data export, Control-E, save to file

      File I/O handler: built-in, class-name

    Data connect, Control-C, open socket

      Socket I/O handler: built-in, class-name

  4

    Drag and drop JSON window content

    Teleview window content via XMPP

    Print screen, Control-P, save to file

  5

    Tabbed window for multiple content panes


Imports

  Lessons learned from previous work 

  * A scalable layout process requires a definition that promotes
    method definition and process consistency, and avoids cyclic
    process dependencies and reduced application degrees of freedom

    * Scaling depends on window frame boundaries, and propagates via
      component boundaries

    * Scaling the component requires processes (algorithms) which take
      its boundaries as input, not output (and not both!)

  * Input coordinate space differs from the output coordinate space

    * A menu bar or display container will be inside the input space
      but outside the output space

  * The drawing of a component should not clip to the component

    * A component should be free to draw beyond its boundaries

      * For example borders decoration or content rotation

  * A coordinate local transform should be independent of the
    component parent transform

    * A component should be free to choose its internal
      transform/input/output strategy

  * Feature implementation should be defined via subclasses rather
    than enums

    * Feature definition via enum proposes an unmanageable and
      impractical application space

  * Input events should be passed to a component as translated to its
    local coordinate space

    * Natural pattern

Design

  See src/vector/Component.java
  See src/vector/Event.java

  The intent is to define the package in the Component interfaces.
  Any implementor of the Component interface is a first class member
  of this package.  However it is also true that gaps in the
  documentation should be filled by looking at the sources in this
  package.

  Operators

    The component interface defines an extended set of life cycle
    operators with void return types.  These are 'init', 'destroy',
    'resized', 'modified' and 'relocated', and are documented in the
    Component interface.  These operators are indempotent: any number
    of calls must produce identical state.

    The initializer and destructor must return with an instance state
    that is consistent with each other and the whole instance object
    life cycle.

    The destructor (named 'destroy') is called by the initializer
    (named 'init'), and is responsible for releasing cyclic references
    and clearing implied state: internal, typically private, state
    that is implied by properties that define output.

    The initializer is called after construction and after setting the
    parent component.  Also, it may be called in a reinitialization
    process defined in a JSON scene description.  It is responsible
    for clearing and redefining the state of an object as first
    constructed and added to the component hierarchy.

  Description

    The primary definition of the JSON description language requires
    the outer - most or top level JSON syntax be the JSON Object
    syntax for the Root Container (Display).  Likewise all Components
    are described by JSON Object syntax.  Containers define their
    children (immediate descendants) in an array named "components".

    Currently, Component property names and values are largely defined
    in the non - abstract members of the Component class, in addition
    to the documentation found in the Component class.  Nonetheless, a
    consistent language is imperative.  New members of the Component
    class must employ the JSON syntax and semantics of the pre -
    existing members of the class wherever possible.

    Each Component is required to produce JSON output that includes a
    property named "class" with the string value of
    "this.getClass().getName()".  This is implemented in
    AbstractComponent and employed by its subclasses by calling
    "super.toJson()".

  Coordinate spaces

    A component's local transform is a matrix that does not include
    the translation (dx,dy) from the parent coordinate space.  

    The translation from the parent is the location coordinates of the
    component relative to its parent container.  Of course, the local
    transform may also scale or scew.

    A component's parent transform includes the local transform and
    the translation coordinates from its parent container.

    A component's "shape coordinate space" is contained under the
    local transform.  It is the coordinate space of a shape displayed
    in this package.  The origin of the shape coordinate space is the
    component's own (0,0) point.

    A component's "local coordinate space" is related to its parent
    coordinate space via the parent transform.  The origin of the
    local coordinate space is the (0,0) point of its parent.  

    Because both the local and parent transforms are closely related
    to the "local coordinate space", the term "local coordinate space"
    may be employed in a number of contexts for a variety of meanings.
    For example, it has been employed to refer to the translation from
    parent to component independent of scaling.  Or, it could be
    employed as a synonym for the (abstract) shape coordinate space.
    Hopefully, in the use of these terms, there's not enough ambiguity
    to obscure an intended meaning.

  Dimensions

    Component bounds are in the parent's coordinate space.  Shape
    bounds are in the shape coordinate space.

    It can be useful to simplify this relationship by thinking of the
    parent's coordinate space as if the nominal "screen" coordinate
    space.

Implementation

  See src/vector/Abstract.java, etc..

  Patterns common to this package

  * Required instance properties have default values, where possible

    * Setters and Destructors should never clear fields having default
      values

    * Setters should ignore null arguments, where possible

  * Instance property setters and getters should ignore null values
    called by fromJson

    * This allows the fromJson method to be defined as a simple,
      unconditional execution list -- which is a convenient and
      reliable pattern that is easily reproduced and maintained

  * The init/destroy paradigm can be subtle in the choice of fields to
    clear in the destructor, and define in the initializer

    * Typically, the destructor clears the same fields as the modifier
      ('modified' method), and the initializer

    * Any state implied (indirectly) by user properties for output is
      cleared by the modifier

  * The derivation of implied state (for example shape from data)
    depends on the explicit state of visualization data and properties

    * Producing default property values into fields will obscure the
      user's intended state of these properties from the life cycle
      operators, and will propagate incorrect state via JSON

    * Methods producing implied state should not produce default
      values into their respective fields, as illustrated in the case
      of the shape method (see Grid and Text)

    * Methods producing implied state must return null when
      dependencies are not available, preserving the logic of state
      production processes and life cycle operators
