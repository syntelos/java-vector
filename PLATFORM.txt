
Portable pixel programming


  Overview

    In order to maximize performance, platform adaptation is performed
    in the java class path by a java compiler.

    This choice permits any platform to be adapted to vector through a
    compiler that sources the Java Programming Language, or Java Class
    File Format.


  Objective 

    The "javac" class path is a type prover.  

    An application compiles to a platform, or compiles to prove
    portability, through the conventional java class path.


  Solution

    A common "platform" software package is available in multiple
    flavors.  Each platform class file archive supports type proving,
    or a runtime.

          Runtime                 Archive

          AWT                     vector-awt-X.Y.Z.jar
          Android                 vector-android-X.Y.Z.jar
          N/A (Portability Test)  vector-platform-X.Y.Z.jar


    The vector runtime class path is a combination of the vector
    library compiled to the platform, with the platform.

          Runtime                 Archive

          AWT                     vector-X.Y.Z.jar
          Android                 vector-X.Y.Z.jar
          N/A (Portability Test)  vector-X.Y.Z.jar


    An application class path requires the application compiled to a
    particular vector runtime class path.


  Building

      Run

          ant <platform>

      to enter the <platform> state in the binary archives.  For
      example, "ant awt" or "ant android" or "ant prove".

      A typical build error mixes the runtime in a javac class path.
      The compiler complains of foreign runtime classes not found.

      Before performing a build on a unique platform, run a build for
      that platform as shown above, "ant <platform>".

      Examples of the errors that arise from mixed platforms include
      compiler errors for a foreign platform (compiling an AWT runtime
      produces errors for Android classes not found), or, running an
      application produces errors for a platform method not found.

      In this case, one or more of the archives in that javac class
      path will have been compiled for the foreign platform.

      In non - platform archives, this is indicated in the manifest
      class path.

          vector-X.Y.Z.jar
            /META-INF/MANIFEST.MF
              Class-Path: vector-<platform>-X.Y.Z.jar

      In a platform archive, the class path is not helpful.

          vector-<platform>-X.Y.Z.jar
            /META-INF/MANIFEST.MF
              Class-Path: vector-X.Y.Z.jar

      To ensure a clean build, run 

          ant <platform>
      or
          ant <platform>-vector

      (once) to switch platforms.

      Subsequently, any builds in that platform will find the archives
      in the <platform> state.

      See also "ant -p" and "ant help".

  Design

    There's two architectural strategies: one in which the API is in
    the platform package, and another in which the API is in the
    vector package.

    Background

      Ideally, the API would be in the vector package.  However, this
      strategy has only one tactic: interfaces and factories.

      In such an approach, portable factory functions would call
      constructors using the portable class name "platform.Classname".

      The vector architecture drops the factory and presents the
      "platform.Classname" for direct use.

    API platform

      The platform package implements vector package interfaces for
      operator classes like the graphics context, and presents common
      required geometric classes like Path, Rectangle and Ellipse.

    API vector

      The vector package is primarily a component scene graph for
      interactive applications.  A reasonable level of convenience
      implies a dependence on the platform package as highlighted in
      the case of the Color and Font classes.

      The Color and Font classes are employed in an operational way.
      Without public or protected access to internal data fields, use
      is exclusive to method calls.  However, they are not purely
      operational because library code usage is dominated by the use
      of constructors for these classes.  A vector package interface
      is not a complete solution in this case.

      The Color and Font classes are not members of the same
      structural or architectural case as geometry classes.

      A collection of vector geometry classes will be adapted to each
      platform Path implementation.  This choice maximizes utility
      subject to platform options.

      The solution of the Path binding problem on the Android platform
      will require the adaptation class to replicate path data in
      memory.  Users of the android graphics Path class are unable to
      retrieve path data entered into the (native) API.  


  Status

    AWT: (beta)
    android: (planned future)
    prove: (try it)
    html5+webgl: (possible future with gwtcc)
    jogl: (planned future)

  Author

    John Pritchard, jdp@syntelos.org
    Software Engineer, The DigiVac Company
    Leonardo, NJ

